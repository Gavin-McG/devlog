---
layout: default
title: F24 Blog Post 1
date: 2024-10-13
permalink: /F24/post-1/
---

Weekly Meeting #1
{: .task time="2.5h"}
To kick off this week's meeting we began with some icebreakers. Shortly following, a brief demo was given to
introduce the basics of using Notion. It was a new software to me, but it was pretty easy to pick up on. A
similar demonstration was given to introduce Gitlab, at which point I cloned the existing directory for project
Sandcastle.
The teams were the semester were announced. I was on R&D team #1 alongside Connor Spears and Nadav Havilio. I
was happy being on R&D, as I'm not too partial to the strategy genre of project Sandcastle. We began the second
part of the meeting within our own groups. Us R&D teams were assigned to decide on a game genre and spend the
week doing research to disocver what makes a game within that genre succesful.



R&D Meeting (9/30/24)
{: .task time="1h"}
Our R&D group met on a discord call to establish the genre for the game we would be developing. The main ideas
we discussed were platformer, fighting game, and management simulator. We decided against platformer, as
Wolverinesoft Studio had very recently created a platformer game. During the previous weekly meeting Connor and
I had tossed around the idea of a managment simulator, which is where we as a group settled. We are leaning in
the direction of a fantasy/magic based game as it opens up many potential features and ideas going forward. It
also fits very well with Nedav's perferred art direction.

Once we were decided on our genre, we moved on to establishing our tasks for the rest of the week. We would need
to research management simulator games. I suggested a particular emphasis on what makes succesful games of this
genre feel entertaining rather than monotonous. We decided that we would meet again later in the week to
consolodate our research and establish more concrete ideas for the game's direction to bring to the next weekly
meeting.



Unity TileMaps
{: .task time="1.5h"}
knowing that our game was more than likely going to use some form of tile-based system, I wanted to make sure I
was sufficienty experienced in using tilemaps. Tilemaps are not a feature of Unity that I've used in the past.
Most of my past projects are 3D and never needed them. To make sure I at least knew the basics, I wanted to
create a basic hexagon tilemap that used multiple tiles for a basic scene. To accomplish this I created two
basic sprites, a ground sprite and a water sprite, then followed along with online tutorials.

The main issue I faced was that the two different sprites I had wouldn't order correctly according to the grid's
ordering system. Either all ground sprites would overlap all water sprites or visa verse, independant of grid
order. As it turns out, this was a result of the two sprites I used being from seperate textures. Once the two
sprites were combined into a single texture then sliced into seperate sprites the ordering issues resolved
themselves.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/HexMapScripted.png" />
Completed Basic Scene using a Unity tilemap.
{: .caption }



TileMap Script Editing
{: .task time="30m"}
Once I knew how to create and use tilemaps in the editor, I wanted to ensure I knew how to modify them via
scripts. I wanted to use scripts to create two lines of tiles along the x and y directions. This would help to
teach me to use tilemaps in scripts and demonstrate how a tilemap's coordinate system works in a hex grid. I
briefly skimmed the Unity documentation and found TileMap.SetTile() would be the best option to accomplish this.
I immediatly ran into issues creating the script, as my IDE refused to recognise the TileMap object. After a
brief search I found it was because I needed to manually include the UnityEngine.TileMap library. Once that was
done it was as simple as creating a simple for loop.
<div class="code" href="{{site.baseurl}}/assets/F24/post-1/Scripts/HexGrid.cs"></div>

The x coordinate was exactly as I would have expected, being straight across. The y coordinate was more
interesting, zagging from side to side along the axis. If we do go along with the idea of a hex grid in our
final project I will need to be sure to keep aware of this when adding new features.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/HexMapScripted.png" />
Altered tilemap resulting from script
{: .caption }



Genre Reserch
{: .task time="1h"}
My research into what makes a good management simulator game included looking through user reviews and review
articles for popular games of the genre. The games I looked into included Cities: Skylines, Cities: Skylines II,
and Factorio. Cities: Skylines and Factorio both represented examples of renowned and succesful games, while
Cities: Skylines II, which has a much more negative rating, could provide insight on what to avoid.

By the end of my research I had several major take aways. One is that the world should feel alive. The actions
and decisions of the player should appear to affect the games environments and inhabitants and the behavior of
the world should influence the players decisions. Games that accomplish this seem to succeed in being engaging,
while ones that don't make the game's visuals feel like a facade.

My second main takeaway I'd like to mention is that the player is almost never given all their tools from the
get-go. Starting out the player had a more limited number of options, and slowly gain new tools, technologies,
or otherwise. This keeps the game interesting as the player progresses by preventing the gameplay from feeling
monotonous or reptetive. It allows the player, once they're comfortable, to move onto new techniques and
strategies to feel a continuous sense of learning and accomplishment. To add onto this, most games seem to make
mistakes very easily reverable to encourage this learning process.



Stylized Water Shader
{: .task time="2h"}
Even if we as a group haven't yet decided exactly what sortof game we're going to make, it's a safe bet that
there will be water in the game. For that reason I wanted to get a head start in creating a water shader that
could be used in our game. Aside from just looking like water, a proper water shader would need to be able to
change over time. Before jumping right into HLSL code, I begin "drafting" the shader using Blender's shader
editor. I ended up with a result very close to what I was imagining.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/BlenderWater.png" />
Draft of shader in Blender
{: .caption }

Next I needed to adapt this shader over to Unity. This was easier said than done, though as the Blender shader
required the use of a Voronoi texture. As far as I'm aware, Unity nor HLSL have any sort of built in voronoi
texture. Instead, I attemped to use a simple version of the function I found online. The Blender shader uses
both F1 and smooth F1 voronoi. Unfortunately, the smoothmin function I used for smooth F1 didn't accurately
replicate Blender's Smooth F1 texture.

With some more research I was able to find a repository of the code used by Blender. Once I found the function
used by the voronoi shader node I just had to adapt it from C++ to HLSL. There were some utility functions I had
to find online aswell, such as smoothstep and mix. With the voronoi textures implimented all I had left to do
was replicate the rest of the shader graph in HLSL, which was a fairly easy task.

<img src="{{site.baseurl}}/assets/F24/post-1/Images/UnityWater.png" />
Finished stylized water shader
{: .caption }
<div class="code" href="{{site.baseurl}}/assets/F24/post-1/Scripts/VoronoiShader.shader"></div>



R&D Meeting 10/5/24
{: .task time="1h"}
Our group met up again on Discord. Out goal was both to discuss our major take aways from our genre research and
establish major details of the game that we would need going forward. We all were settled on the idea of the
player finding a dragon heart amonst a large dragon skeleton, then building up a magic-based town surrounding
the heart. Some of the major details we discussed included what the main way the game would progress is,
requirments of the building system, game mechanics and functions, types of buildings, major character concepts,
and other necessary concepts like lore, dialogue system, and UI.



Weekly Meeting #2
{: .task time="2h"}
The goal of this meeting for the R&D groups was to finalize key idea, create a timeline, and allocate tasks for
the next several weeks. Most of the ideation and key concepts for out game were established in our most previous
R&D meeting, so we went straight to assigning tasks and creating a timeline. For our timeline we have 2 main
goals. The first is to get a product that can be playtested with a month or so to get first impressions on our
game and make any necessary changes. Second, we want to have a sufficeint prototype of our game in time for the
showcase

For smaller tasks, we assigned several tasks for each memeber to complete in the next couple of weeks. I will be
working on the building system with the goal of finishing by the end of the week. Connor would be working on UI
and Nadav would be finalizing the style and references for the art direction of the game.



Cubic Coordiantes
{: .task time="1h"}
As was mentioned previously within the "Tilemap Script Editing" task, the default coordinate system for hex
tilemaps, often called offset coordiantes, are somewhat irregualar and would be difficult to use going forward.
Instead of using this system, I wanted to create a conversion between this and a much more convienient
coordinate system called cubic coordinates. This coordinate system introdcues a new Z coordinate, which may seem
odd for a 2-dimentional coordinate system, but using it makes the tiles much more consistent in terms of a
tile's difference from its neighbor, which will be vitally important for a building system going forward.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/cube-diagram.png" />
Example of cubic coordinates on a 2D hexmap
{: .caption }

I created a function Library called HexUtils which would house the functions for converting between offset
coordinates and cubic coordinates. I introduced some overloading for representing offset coordinates in either a
Vector2Int or Vector3Int, as many of Unity's function represent it in 3 dimentions with an empty z value. The
exact means of converting between these coordiante systems was fairly easy to find online.

The only issue I ran into when completing this task was that the functions I found online didn't work well for
negative numbers. Supposedly integer division in C# rounds differently than whatever pltform being used by the
creator of the article. Once this slight issue was resolved I created a quick script to confirm the HexUtils
functions were working as intended be placing lines of tiles in all 3 directions.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/HexCoordinates.png" />
succesful result of placing tiles along each coordinate dimention
{: .caption }
<div class="code" href="{{site.baseurl}}/assets/F24/post-1/Scripts/HexUtils.cs"></div>



Building System
{: .task time="8h"}
Constructing the building system was my major task for this cycle. Getting this system in place would be vital
before we could move onto more involved game system. The goals for thus system was to be able to place
buildings, delete buildings, and create a system where other scripts would convieniently be able to retrieve
information of what buildings were in place. In the future I could add options to move buildings, but this was
not a priority. I also wanted to have support for multiple-tile buildings

I decided to start by establishing out the layers that would be needed for the game's tilemap. The three layers
I decided on was the ground layer, the object layer, and the preview layer. The ground layer would store the
terrain tiles. The object layer would store building tiles or other environmental features. The preview layer
would be used for previewing buildings to be placed or any other use we can make of it later.

To establish how the building system would work, I had to decide how to determine whether a given tile was
"valid". I decided that each tile would either have a label "Full" or "Empty". A valid tile to place a building
would have to have a "Full" tile in the ground layer and an "empty" tile in the object layer.

I began by trying to figure out how to label each tile with a respective "Full" or "Empty" label. I tried to
create a ScriptableObject That would group tiles with their respective labels, and the build system would use
these objects to access tiles. I found this option to be very bloated, requiring two objects in the project
files for each tile and complicating the code. Instead, I created a customTile class which extends from Tile
this stores this label value. I changed all the existing tiles to this CustomTile object.
<div class="code" href="{{site.baseurl}}/assets/F24/post-1/Scripts/CustomTile.cs"></div>

Next, I created a Structure object. The structure object stores either one or a set of tiles to describe the
tiles that make up a building. Each structure also has a label for type of building. Each tile within the
Structure was contained in a StructurePiece struct which would also store the relative coordinate to the
building's center.
<div class="code" href="{{site.baseurl}}/assets/F24/post-1/Scripts/Structure.cs"></div>

The bulk of the actual building process is controlled by a script I named BuildingManager. This script contains
an enumerator for the current editing mode and a structure for the actively selected building. It also contains
several other parameters used primarily for color options. Aside from just placing the necessary tiles in the
correct positions the building manager also needed to track what tiles correspond to what building. For this I
created three different dictionaries. One tracks a tile's coordinate to the building that is one it, the second
contains a list of tiles that each building covers, and the last tracks a list of buildings for each building
type. The building type dictionary isn't needed for this script, but would likely be useful in the future.

Conner Spears had previously created a system for highlighting the tile the mouse was hovering over. I moved the
functionality of that script into the BuildingManager script as part of the building system. I also improved it
so that an entire building was highlighted when hovered over as opposed to one tile. The final feature I added
were Unity events to make it simpler for UI and control scripts to interact seamlessly with the building system.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/BuildingSystem.png" />
Image of the building system, with a multi-tile building being previewed in green
{: .caption }
<div class="code" href="{{site.baseurl}}/assets/F24/post-1/Scripts/BuildingManager.cs"></div>



Documentation
{: .task time="1.5h"}
To finish off this sprint I created documentation for the code I had made so far. This documentation included
the functions and purposes of the BuildingManager, Structure, Building, and CustomTile scripts. It also included
background information and recommended practice when interacting with coordinate systems and creating new
buildings and tiles. I used chatgpt to aid in describing the parameters and return values of each of the
functions.
<img src="{{site.baseurl}}/assets/F24/post-1/Images/ProgrammingDocumentation.png" />
Image of the Building Manager script in the documentation
{: .caption }
